
/*

$$$$$$\            $$\                                               
$$  __$$\           $$ |                                              
$$ /  \__|$$\   $$\ $$$$$$$\  $$$$$$$$\  $$$$$$\   $$$$$$\   $$$$$$\  
\$$$$$$\  $$ |  $$ |$$  __$$\ \____$$  |$$  __$$\ $$  __$$\ $$  __$$\ 
 \____$$\ $$ |  $$ |$$ |  $$ |  $$$$ _/ $$$$$$$$ |$$ |  \__|$$ /  $$ |
$$\   $$ |$$ |  $$ |$$ |  $$ | $$  _/   $$   ____|$$ |      $$ |  $$ |
\$$$$$$  |\$$$$$$  |$$$$$$$  |$$$$$$$$\ \$$$$$$$\ $$ |      \$$$$$$  |
 \______/  \______/ \_______/ \________| \_______|\__|       \______/

Project Name : SubZero MD
Creator      : Darrell Mucheri ( Mr Frank OFC )
Repo         : https//github.com/mrfrank-ofc/SUBZERO-MD
Support      : wa.me/18062212660
*/










































































































































































































/*
const {
  cmd,
  commands
} = require("../command");
cmd({
  'pattern': "hand",
  'desc': "Displays a dynamic edit msg for fun.",
  'category': "tools",
  'react': '‚úä',
  'filename': __filename
}, async (_0x45cd83, _0x286d49, _0x19855e, {
  from: _0x96d404,
  reply: _0x47c6bc
}) => {
  try {
    const _0x1d39fa = await _0x45cd83.sendMessage(_0x96d404, {
      'text': "‚úäüèª *STARTED...* üí¶"
    });
    const _0x3eccb1 = ['8‚úäÔ∏è===D', "8=‚úäÔ∏è==D", "8==‚úäÔ∏è=D", "8===‚úäÔ∏èD", "8==‚úäÔ∏è=D", "8=‚úäÔ∏è==D", "8‚úäÔ∏è===D", "8=‚úäÔ∏è==D", "8==‚úäÔ∏è=D", '8===‚úäÔ∏èD', "8==‚úäÔ∏è=D", "8=‚úäÔ∏è==D", '8‚úäÔ∏è===D', "8=‚úäÔ∏è==D", "8==‚úäÔ∏è=D", "8===‚úäÔ∏èD", "8==‚úäÔ∏è=D", '8=‚úäÔ∏è==D', "8‚úäÔ∏è===D", '8=‚úäÔ∏è==D', "8==‚úäÔ∏è=D", "8===‚úäÔ∏èD üí¶", "8==‚úäÔ∏è=Düí¶ üí¶", "8=‚úäÔ∏è==D üí¶üí¶ üí¶"];
    for (const _0x406c5e of _0x3eccb1) {
      await new Promise(_0x2b41ff => setTimeout(_0x2b41ff, 0x3e8));
      await _0x45cd83.relayMessage(_0x96d404, {
        'protocolMessage': {
          'key': _0x1d39fa.key,
          'type': 0xe,
          'editedMessage': {
            'conversation': _0x406c5e
          }
        }
      }, {});
    }
  } catch (_0x57d8ae) {
    console.log(_0x57d8ae);
    _0x47c6bc("‚ùå *Error!* " + _0x57d8ae.message);
  }
});
cmd({
  'pattern': "happy",
  'desc': "Displays a dynamic edit msg for fun.",
  'category': "tools",
  'react': 'üòÅ',
  'filename': __filename
}, async (_0x353111, _0x52aa7e, _0x362309, {
  from: _0x3d98dd,
  reply: _0x46f413
}) => {
  try {
    const _0xce6d4d = await _0x353111.sendMessage(_0x3d98dd, {
      'text': 'üòÇ'
    });
    const _0x47a009 = ['üòÉ', 'üòÑ', 'üòÅ', 'üòä', 'üòé', 'ü•≥', 'üò∏', 'üòπ', 'üåû', 'üåà', 'üòÉ', 'üòÑ', 'üòÅ', 'üòä', 'üòé', 'ü•≥', 'üò∏', 'üòπ', 'üåû', 'üåà', 'üòÉ', 'üòÑ', 'üòÅ', 'üòä'];
    for (const _0x445d2a of _0x47a009) {
      await new Promise(_0x3a1a76 => setTimeout(_0x3a1a76, 0x320));
      await _0x353111.relayMessage(_0x3d98dd, {
        'protocolMessage': {
          'key': _0xce6d4d.key,
          'type': 0xe,
          'editedMessage': {
            'conversation': _0x445d2a
          }
        }
      }, {});
    }
  } catch (_0x3d2162) {
    console.log(_0x3d2162);
    _0x46f413("‚ùå *Error!* " + _0x3d2162.message);
  }
});
cmd({
  'pattern': "heart",
  'desc': "Displays a dynamic edit msg for fun.",
  'category': "tools",
  'react': 'ü´Ä',
  'filename': __filename
}, async (_0x468a9f, _0x3a7e90, _0xac39dc, {
  from: _0x53a037,
  reply: _0x542a66
}) => {
  try {
    const _0x39d571 = await _0x468a9f.sendMessage(_0x53a037, {
      'text': '‚ù§Ô∏è'
    });
    const _0x52271e = ['üíñ', 'üíó', 'üíï', '‚ù§Ô∏è', 'üíõ', 'üíö', 'ü´Ä', 'üíô', 'üíú', 'üñ§', '‚ô•Ô∏è', 'ü§ç', 'ü§é', 'üíó', 'üíû', 'üíì', 'üíò', 'üíù', '‚ô•Ô∏è', 'üíü', 'ü´Ä', '‚ù§Ô∏è'];
    for (const _0x42a679 of _0x52271e) {
      await new Promise(_0xc0ed08 => setTimeout(_0xc0ed08, 0x1f4));
      await _0x468a9f.relayMessage(_0x53a037, {
        'protocolMessage': {
          'key': _0x39d571.key,
          'type': 0xe,
          'editedMessage': {
            'conversation': _0x42a679
          }
        }
      }, {});
    }
  } catch (_0x2f7fbb) {
    console.log(_0x2f7fbb);
    _0x542a66("‚ùå *Error!* " + _0x2f7fbb.message);
  }
});
cmd({
  'pattern': "anger",
  'desc': "Displays a dynamic edit msg for fun.",
  'category': "tools",
  'react': 'ü§°',
  'filename': __filename
}, async (_0x4c63a0, _0x2a2d0f, _0xfd1920, {
  from: _0x7c1f05,
  reply: _0x2fc617
}) => {
  try {
    const _0x471762 = await _0x4c63a0.sendMessage(_0x7c1f05, {
      'text': 'ü§°'
    });
    const _0x4383e5 = ['üò°', 'üò†', 'ü§¨', 'üò§', 'üòæ', 'üò°', 'üò†', 'ü§¨', 'üò§', 'üòæ'];
    for (const _0x562bf3 of _0x4383e5) {
      await new Promise(_0x2be7c0 => setTimeout(_0x2be7c0, 0x3e8));
      await _0x4c63a0.relayMessage(_0x7c1f05, {
        'protocolMessage': {
          'key': _0x471762.key,
          'type': 0xe,
          'editedMessage': {
            'conversation': _0x562bf3
          }
        }
      }, {});
    }
  } catch (_0x44a0c5) {
    console.log(_0x44a0c5);
    _0x2fc617("‚ùå *Error!* " + _0x44a0c5.message);
  }
});
cmd({
  'pattern': "sad",
  'desc': "Displays a dynamic edit msg for fun.",
  'category': "tools",
  'react': 'üò´',
  'filename': __filename
}, async (_0x33fcee, _0x1876fe, _0xc17cb8, {
  from: _0x15bb18,
  reply: _0xee066f
}) => {
  try {
    const _0x4c06fd = await _0x33fcee.sendMessage(_0x15bb18, {
      'text': 'üò≠'
    });
    const _0x2d9a88 = ['ü•∫', 'üòü', 'üòï', 'üòñ', 'üò´', 'üôÅ', 'üò©', 'üò•', 'üòì', 'üò™', 'üò¢', 'üòî', 'üòû', 'üò≠', 'üíî', 'üò≠', 'üòø'];
    for (const _0x336d71 of _0x2d9a88) {
      await new Promise(_0x6eece4 => setTimeout(_0x6eece4, 0x3e8));
      await _0x33fcee.relayMessage(_0x15bb18, {
        'protocolMessage': {
          'key': _0x4c06fd.key,
          'type': 0xe,
          'editedMessage': {
            'conversation': _0x336d71
          }
        }
      }, {});
    }
  } catch (_0x345651) {
    console.log(_0x345651);
    _0xee066f("‚ùå *Error!* " + _0x345651.message);
  }
});
cmd({
  'pattern': 'shy',
  'desc': "Displays a dynamic edit msg for fun.",
  'category': "tools",
  'react': 'üò≥',
  'filename': __filename
}, async (_0x5cfd31, _0x13a257, _0x4fe9cd, {
  from: _0x453318,
  reply: _0x138a01
}) => {
  try {
    const _0x361884 = await _0x5cfd31.sendMessage(_0x453318, {
      'text': "> SUBZERO MD"
    });
    const _0x206081 = ['üò≥', 'üòä', 'üò∂', 'üôà', 'üôä', 'üò≥', 'üòä', 'üò∂', 'üôà', 'üôä'];
    for (const _0x5ccb6e of _0x206081) {
      await new Promise(_0x23b67b => setTimeout(_0x23b67b, 0x3e8));
      await _0x5cfd31.relayMessage(_0x453318, {
        'protocolMessage': {
          'key': _0x361884.key,
          'type': 0xe,
          'editedMessage': {
            'conversation': _0x5ccb6e
          }
        }
      }, {});
    }
  } catch (_0x3775a4) {
    console.log(_0x3775a4);
    _0x138a01("‚ùå *Error!* " + _0x3775a4.message);
  }
});
cmd({
  'pattern': "moon",
  'desc': "Displays a dynamic edit msg for fun.",
  'category': 'tools',
  'react': 'üåô',
  'filename': __filename
}, async (_0x2adc05, _0x574382, _0xe7924c, {
  from: _0x10f877,
  reply: _0x1797ef
}) => {
  try {
    const _0x16fb04 = await _0x2adc05.sendMessage(_0x10f877, {
      'text': 'üåô'
    });
    const _0x226056 = ['üåó', 'üåò', 'üåë', 'üåí', 'üåì', 'üåî', 'üåï', 'üåñ', 'üåó', 'üåò', 'üåë', 'üåí', 'üåì', 'üåî', 'üåï', 'üåñ', 'üåó', 'üåò', 'üåë', 'üåí', 'üåì', 'üåî', 'üåï', 'üåñ', 'üåó', 'üåò', 'üåë', 'üåí', 'üåì', 'üåî', 'üåï', "üåöüåù"];
    for (const _0x3ad6c8 of _0x226056) {
      await new Promise(_0x1eba41 => setTimeout(_0x1eba41, 0x3e8));
      await _0x2adc05.relayMessage(_0x10f877, {
        'protocolMessage': {
          'key': _0x16fb04.key,
          'type': 0xe,
          'editedMessage': {
            'conversation': _0x3ad6c8
          }
        }
      }, {});
    }
  } catch (_0x31361e) {
    console.log(_0x31361e);
    _0x1797ef("‚ùå *Error!* " + _0x31361e.message);
  }
});
cmd({
  'pattern': "confused",
  'desc': "Displays a dynamic edit msg for fun.",
  'category': 'tools',
  'react': 'üôÄ',
  'filename': __filename
}, async (_0x4e5dcf, _0x197ed7, _0x4e6e55, {
  from: _0x419892,
  reply: _0x1f258d
}) => {
  try {
    const _0x566b9e = await _0x4e5dcf.sendMessage(_0x419892, {
      'text': 'üôÄ'
    });
    const _0x35a517 = ['üòï', 'üòü', 'üòµ', 'ü§î', 'üòñ', 'üò≤', 'üò¶', 'ü§∑', "ü§∑‚Äç‚ôÇÔ∏è", 'ü§∑‚Äç‚ôÄÔ∏è'];
    for (const _0x177123 of _0x35a517) {
      await new Promise(_0x19e7ff => setTimeout(_0x19e7ff, 0x3e8));
      await _0x4e5dcf.relayMessage(_0x419892, {
        'protocolMessage': {
          'key': _0x566b9e.key,
          'type': 0xe,
          'editedMessage': {
            'conversation': _0x177123
          }
        }
      }, {});
    }
  } catch (_0x3914f5) {
    console.log(_0x3914f5);
    _0x1f258d("‚ùå *Error!* " + _0x3914f5.message);
  }
});
cmd({
  'pattern': 'kiss',
  'desc': "Displays a dynamic edit msg for fun.",
  'category': "tools",
  'react': '‚ô•Ô∏è',
  'filename': __filename
}, async (_0x5534d6, _0xea351e, _0x4a659, {
  from: _0x3549d3,
  reply: _0x38bcdd
}) => {
  try {
    const _0x3d3056 = await _0x5534d6.sendMessage(_0x3549d3, {
      'text': '‚ô•Ô∏è'
    });
    const _0x548d62 = ['ü•µ', '‚ù§Ô∏è', 'üíã', 'üò´', 'ü§§', 'üòã', 'ü•µ', 'ü•∂', 'üôä', 'üòª', 'üôà', 'üíã', 'ü´Ç', 'ü´Ä', 'üëÖ', 'üëÑ', 'üíã'];
    for (const _0x2ae417 of _0x548d62) {
      await new Promise(_0x3260b1 => setTimeout(_0x3260b1, 0x3e8));
      await _0x5534d6.relayMessage(_0x3549d3, {
        'protocolMessage': {
          'key': _0x3d3056.key,
          'type': 0xe,
          'editedMessage': {
            'conversation': _0x2ae417
          }
        }
      }, {});
    }
  } catch (_0x1763fc) {
    console.log(_0x1763fc);
    _0x38bcdd("‚ùå *Error!* " + _0x1763fc.message);
  }
});
cmd({
  'pattern': 'nikal',
  'desc': "Displays a dynamic edit msg for fun.",
  'category': "tools",
  'react': 'üóø',
  'filename': __filename
}, async (_0x125191, _0x3f957c, _0xb9d01a, {
  from: _0x3ae285,
  reply: _0x30a5f5
}) => {
  try {
    const _0x19567b = await _0x125191.sendMessage(_0x3ae285, {
      'text': "Mr Frank OFCüóø"
    });
    const _0x1c80f3 = ["‚†Ä‚†Ä‚†Ä‚£†‚£∂‚°æ‚†è‚†â‚†ô‚†≥‚¢¶‚°Ä‚†Ä‚†Ä‚†Ä‚¢†‚†û‚†â‚†ô‚†≤‚°Ä‚†Ä\n ‚†Ä‚£¥‚†ø‚†è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä     ‚¢≥‚°Ä‚†Ä‚°è‚†Ä‚†Ä‚†Ä   ‚†Ä  ‚¢∑\n‚¢†‚£ü‚£ã‚°Ä‚¢Ä‚£Ä‚£Ä‚°Ä‚†Ä‚£Ä‚°Ä   ‚£ß‚†Ä‚¢∏‚†Ä‚†Ä‚†Ä  ‚†Ä    ‚°á\n‚¢∏‚£Ø‚°≠‚†Å‚†∏‚£õ‚£ü‚†Ü‚°¥‚£ª‚°≤     ‚£ø  ‚£∏   Mr   ‚°á\n ‚£ü‚£ø‚°≠‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢±‚†Ä‚†Ä      ‚£ø  ‚¢π‚†Ä          ‚°á\n  ‚†ô‚¢ø‚£Ø‚†Ñ‚†Ä‚†Ä‚†Ä__‚†Ä   ‚†Ä   ‚°ø ‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚†Ä    ‚°º\n‚†Ä‚†Ä‚†Ä‚†π‚£∂‚†Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°¥‚†É‚†Ä   ‚†ò‚†§‚£Ñ‚£†‚†û‚†Ä\n‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£∑‚°¶‚¢§‚°§‚¢§‚£û‚£Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚†Ä‚¢Ä‚£§‚£¥‚£ø‚£è‚†Å‚†Ä‚†Ä‚†∏‚£è‚¢Ø‚£∑‚£ñ‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚¢Ä‚£æ‚£Ω‚£ø‚£ø‚£ø‚£ø‚†õ‚¢≤‚£∂‚£æ‚¢â‚°∑‚£ø‚£ø‚†µ‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚£º‚£ø‚†ç‚†â‚£ø‚°≠‚†â‚†ô‚¢∫‚£á‚£º‚°è‚†Ä‚†Ä ‚†Ä‚£Ñ‚¢∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä`", "‚†Ä‚†Ä‚†Ä‚£†‚£∂‚°æ‚†è‚†â‚†ô‚†≥‚¢¶‚°Ä‚†Ä‚†Ä‚†Ä‚¢†‚†û‚†â‚†ô‚†≤‚°Ä‚†Ä\n ‚†Ä‚£¥‚†ø‚†è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä  ‚†Ä  ‚¢≥‚°Ä‚†Ä‚°è‚†Ä‚†Ä‚†Ä   ‚†Ä  ‚¢∑\n‚¢†‚£ü‚£ã‚°Ä‚¢Ä‚£Ä‚£Ä‚°Ä‚†Ä‚£Ä‚°Ä   ‚£ß‚†Ä‚¢∏‚†Ä‚†Ä‚†Ä       ‚°á\n‚¢∏‚£Ø‚°≠‚†Å‚†∏‚£õ‚£ü‚†Ü‚°¥‚£ª‚°≤     ‚£ø  ‚£∏   Frank   ‚°á\n ‚£ü‚£ø‚°≠‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢±‚†Ä‚†Ä      ‚£ø  ‚¢π‚†Ä          ‚°á\n  ‚†ô‚¢ø‚£Ø‚†Ñ‚†Ä‚†Ä|__|‚†Ä‚†Ä   ‚°ø ‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚†Ä    ‚°º\n‚†Ä‚†Ä‚†Ä‚†π‚£∂‚†Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°¥‚†É‚†Ä   ‚†ò‚†§‚£Ñ‚£†‚†û‚†Ä\n‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£∑‚°¶‚¢§‚°§‚¢§‚£û‚£Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚†Ä‚¢Ä‚£§‚£¥‚£ø‚£è‚†Å‚†Ä‚†Ä‚†∏‚£è‚¢Ø‚£∑‚£ñ‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚¢Ä‚£æ‚£Ω‚£ø‚£ø‚£ø‚£ø‚†õ‚¢≤‚£∂‚£æ‚¢â‚°∑‚£ø‚£ø‚†µ‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚£º‚£ø‚†ç‚†â‚£ø‚°≠‚†â‚†ô‚¢∫‚£á‚£º‚°è‚†Ä‚†Ä ‚†Ä‚£Ñ‚¢∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä`", "‚†Ä‚†Ä‚†Ä‚£†‚£∂‚°æ‚†è‚†â‚†ô‚†≥‚¢¶‚°Ä‚†Ä‚†Ä‚†Ä‚¢†‚†û‚†â‚†ô‚†≤‚°Ä‚†Ä\n ‚†Ä‚£¥‚†ø‚†è‚†Ä‚†Ä     ‚†Ä   ‚¢≥‚°Ä‚†Ä‚°è‚†Ä‚†Ä    ‚†Ä  ‚¢∑\n‚¢†‚£ü‚£ã‚°Ä‚¢Ä‚£Ä‚£Ä‚°Ä‚†Ä‚£Ä‚°Ä   ‚£ß‚†Ä‚¢∏‚†Ä‚†Ä‚†Ä‚†Ä      ‚°á\n‚¢∏‚£Ø‚°≠‚†Å‚†∏‚£õ‚£ü‚†Ü‚°¥‚£ª‚°≤    ‚£ø  ‚£∏   OFC   ‚°á\n ‚£ü‚£ø‚°≠‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢±‚†Ä‚†Ä     ‚£ø  ‚¢π‚†Ä           ‚°á\n  ‚†ô‚¢ø‚£Ø‚†Ñ‚†Ä‚†Ä(P)‚†Ä‚†Ä     ‚°ø ‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚†Ä    ‚°º\n‚†Ä‚†Ä‚†Ä‚†π‚£∂‚†Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°¥‚†É‚†Ä   ‚†ò‚†§‚£Ñ‚£†‚†û‚†Ä\n‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£∑‚°¶‚¢§‚°§‚¢§‚£û‚£Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚†Ä‚¢Ä‚£§‚£¥‚£ø‚£è‚†Å‚†Ä‚†Ä‚†∏‚£è‚¢Ø‚£∑‚£ñ‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚¢Ä‚£æ‚£Ω‚£ø‚£ø‚£ø‚£ø‚†õ‚¢≤‚£∂‚£æ‚¢â‚°∑‚£ø‚£ø‚†µ‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚£º‚£ø‚†ç‚†â‚£ø‚°≠‚†â‚†ô‚¢∫‚£á‚£º‚°è‚†Ä‚†Ä ‚†Ä‚£Ñ‚¢∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä`", "‚†Ä‚†Ä‚†Ä‚£†‚£∂‚°æ‚†è‚†â‚†ô‚†≥‚¢¶‚°Ä‚†Ä‚†Ä‚†Ä‚¢†‚†û‚†â‚†ô‚†≤‚°Ä‚†Ä\n ‚†Ä‚£¥‚†ø‚†è‚†Ä‚†Ä     ‚†Ä   ‚¢≥‚°Ä‚†Ä‚°è‚†Ä‚†Ä    ‚†Ä  ‚¢∑\n‚¢†‚£ü‚£ã‚°Ä‚¢Ä‚£Ä‚£Ä‚°Ä‚†Ä‚£Ä‚°Ä   ‚£ß‚†Ä‚¢∏‚†Ä   ‚†Ä     ‚°á\n‚¢∏‚£Ø‚°≠‚†Å‚†∏‚£õ‚£ü‚†Ü‚°¥‚£ª‚°≤    ‚£ø  ‚£∏  Zimbabwe  ‚°á\n ‚£ü‚£ø‚°≠‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢±‚†Ä        ‚£ø  ‚¢π‚†Ä          ‚°á\n  ‚†ô‚¢ø‚£Ø‚†Ñ‚†Ä‚†Ä‚†Ä__ ‚†Ä  ‚†Ä   ‚°ø ‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚†Ä    ‚°º\n‚†Ä‚†Ä‚†Ä‚†π‚£∂‚†Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°¥‚†É‚†Ä   ‚†ò‚†§‚£Ñ‚£†‚†û‚†Ä\n‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£∑‚°¶‚¢§‚°§‚¢§‚£û‚£Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚†Ä‚¢Ä‚£§‚£¥‚£ø‚£è‚†Å‚†Ä‚†Ä‚†∏‚£è‚¢Ø‚£∑‚£ñ‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚¢Ä‚£æ‚£Ω‚£ø‚£ø‚£ø‚£ø‚†õ‚¢≤‚£∂‚£æ‚¢â‚°∑‚£ø‚£ø‚†µ‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚£º‚£ø‚†ç‚†â‚£ø‚°≠‚†â‚†ô‚¢∫‚£á‚£º‚°è‚†Ä‚†Ä ‚†Ä‚£Ñ‚¢∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä`", "‚†Ä‚†Ä‚†Ä‚£†‚£∂‚°æ‚†è‚†â‚†ô‚†≥‚¢¶‚°Ä‚†Ä‚†Ä‚†Ä‚¢†‚†û‚†â‚†ô‚†≤‚°Ä‚†Ä\n ‚†Ä‚£¥‚†ø‚†è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä      ‚¢≥‚°Ä‚†Ä‚°è‚†Ä‚†Ä    ‚†Ä  ‚¢∑\n‚¢†‚£ü‚£ã‚°Ä‚¢Ä‚£Ä‚£Ä‚°Ä‚†Ä‚£Ä‚°Ä   ‚£ß‚†Ä‚¢∏‚†Ä‚†Ä ‚†Ä      ‚°á\n‚¢∏‚£Ø‚°≠‚†Å‚†∏‚£õ‚£ü‚†Ü‚°¥‚£ª‚°≤    ‚£ø  ‚£∏  Best   ‚°á\n ‚£ü‚£ø‚°≠‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢±‚†Ä‚†Ä       ‚£ø  ‚¢π‚†Ä          ‚°á\n  ‚†ô‚¢ø‚£Ø‚†Ñ‚†Ä‚†Ä|__| ‚†Ä    ‚°ø ‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚†Ä    ‚°º\n‚†Ä‚†Ä‚†Ä‚†π‚£∂‚†Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°¥‚†É‚†Ä   ‚†ò‚†§‚£Ñ‚£†‚†û‚†Ä\n‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£∑‚°¶‚¢§‚°§‚¢§‚£û‚£Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚†Ä‚¢Ä‚£§‚£¥‚£ø‚£è‚†Å‚†Ä‚†Ä‚†∏‚£è‚¢Ø‚£∑‚£ñ‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚¢Ä‚£æ‚£Ω‚£ø‚£ø‚£ø‚£ø‚†õ‚¢≤‚£∂‚£æ‚¢â‚°∑‚£ø‚£ø‚†µ‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚£º‚£ø‚†ç‚†â‚£ø‚°≠‚†â‚†ô‚¢∫‚£á‚£º‚°è‚†Ä‚†Ä ‚†Ä‚£Ñ‚¢∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä`", "‚†Ä‚†Ä‚†Ä‚£†‚£∂‚°æ‚†è‚†â‚†ô‚†≥‚¢¶‚°Ä‚†Ä‚†Ä‚†Ä‚¢†‚†û‚†â‚†ô‚†≤‚°Ä‚†Ä\n ‚†Ä‚£¥‚†ø‚†è‚†Ä‚†Ä‚†Ä‚†Ä   ‚†Ä  ‚†Ä‚¢≥‚°Ä‚†Ä‚°è‚†Ä‚†Ä       ‚¢∑\n‚¢†‚£ü‚£ã‚°Ä‚¢Ä‚£Ä‚£Ä‚°Ä‚†Ä‚£Ä‚°Ä   ‚£ß‚†Ä‚¢∏‚†Ä  ‚†Ä       ‚°á\n‚¢∏‚£Ø‚°≠‚†Å‚†∏‚£õ‚£ü‚†Ü‚°¥‚£ª‚°≤   ‚£ø  ‚£∏   Country   ‚°á\n ‚£ü‚£ø‚°≠‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢±‚†Ä       ‚£ø  ‚¢π‚†Ä           ‚°á\n  ‚†ô‚¢ø‚£Ø‚†Ñ‚†Ä‚†ÄEver‚†Ä‚†Ä   ‚°ø ‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚†Ä   ‚°º\n‚†Ä‚†Ä‚†Ä‚†π‚£∂‚†Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä  ‚°¥‚†É‚†Ä   ‚†ò‚†§‚£Ñ‚£†‚†û‚†Ä\n‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£∑‚°¶‚¢§‚°§‚¢§‚£û‚£Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚†Ä‚¢Ä‚£§‚£¥‚£ø‚£è‚†Å‚†Ä‚†Ä‚†∏‚£è‚¢Ø‚£∑‚£ñ‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚¢Ä‚£æ‚£Ω‚£ø‚£ø‚£ø‚£ø‚†õ‚¢≤‚£∂‚£æ‚¢â‚°∑‚£ø‚£ø‚†µ‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n‚£º‚£ø‚†ç‚†â‚£ø‚°≠‚†â‚†ô‚¢∫‚£á‚£º‚°è‚†Ä‚†Ä ‚†Ä‚£Ñ‚¢∏‚†Ä"];
    for (const _0x77af75 of _0x1c80f3) {
      await new Promise(_0x40d3fb => setTimeout(_0x40d3fb, 0x5dc));
      await _0x125191.relayMessage(_0x3ae285, {
        'protocolMessage': {
          'key': _0x19567b.key,
          'type': 0xe,
          'editedMessage': {
            'conversation': _0x77af75
          }
        }
      }, {});
    }
  } catch (_0x61a6ba) {
    console.log(_0x61a6ba);
    _0x30a5f5("‚ùå *Error!* " + _0x61a6ba.message);
  }
});

*/

const { cmd } = require("../command");
const { fetchGif, gifToVideo } = require("../lib/fetchGif");
const axios = require("axios");

cmd(
    {
        pattern: "cry",
        desc: "Send a crying reaction GIF.",
        category: "fun",
        react: "üò¢",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} is crying over @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is crying!`
                : `> ¬© ùêèùêéùêñùêÑùêëùêÑùêÉ ùêÅùêò ùêíùêîùêÅùêôùêÑùêëùêé`;

            const apiUrl = "https://api.waifu.pics/sfw/cry";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("‚ùå Error in .cry command:", error);
            reply(`‚ùå *Error in .cry command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "cuddle",
        desc: "Send a cuddle reaction GIF.",
        category: "fun",
        react: "ü§ó",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} cuddled @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is cuddling everyone!`
                : `> ¬© ùêèùêéùêñùêÑùêëùêÑùêÉ ùêÅùêò ùêíùêîùêÅùêôùêÑùêëùêé`;

            const apiUrl = "https://api.waifu.pics/sfw/cuddle";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("‚ùå Error in .cuddle command:", error);
            reply(`‚ùå *Error in .cuddle command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "bully",
        desc: "Send a bully reaction GIF.",
        category: "fun",
        react: "üòà",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} is bullying @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is bullying everyone!`
                : `> ¬© ùêèùêéùêñùêÑùêëùêÑùêÉ ùêÅùêò ùêíùêîùêÅùêôùêÑùêëùêé`;

            const apiUrl = "https://api.waifu.pics/sfw/bully";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("‚ùå Error in .bully command:", error);
            reply(`‚ùå *Error in .bully command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "hug",
        desc: "Send a hug reaction GIF.",
        category: "fun",
        react: "ü§ó",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} hugged @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is hugging everyone!`
                : `> ¬© ùêèùêéùêñùêÑùêëùêÑùêÉ ùêÅùêò ùêíùêîùêÅùêôùêÑùêëùêé üñ§`;

            const apiUrl = "https://api.waifu.pics/sfw/hug";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("‚ùå Error in .hug command:", error);
            reply(`‚ùå *Error in .hug command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);


cmd(
    {
        pattern: "awoo",
        desc: "Send an awoo reaction GIF.",
        category: "fun",
        react: "üê∫",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} awoos at @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is awooing everyone!`
                : `> ¬© ùêèùêéùêñùêÑùêëùêÑùêÉ ùêÅùêò ùêíùêîùêÅùêôùêÑùêëùêé`;

            const apiUrl = "https://api.waifu.pics/sfw/awoo";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("‚ùå Error in .awoo command:", error);
            reply(`‚ùå *Error in .awoo command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "lick",
        desc: "Send a lick reaction GIF.",
        category: "fun",
        react: "üëÖ",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);

            let message = mentionedUser ? `${sender} licked @${mentionedUser.split("@")[0]}` : `${sender} licked themselves!`;

            const apiUrl = "https://api.waifu.pics/sfw/lick";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("‚ùå Error in .lick command:", error);
            reply(`‚ùå *Error in .lick command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);
  
cmd(
    {
        pattern: "pat",
        desc: "Send a pat reaction GIF.",
        category: "fun",
        react: "ü´Ç",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} patted @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is patting everyone!`
                : `> ¬© ùêèùêéùêñùêÑùêëùêÑùêÉ ùêÅùêò ùêíùêîùêÅùêôùêÑùêëùêé `;

            const apiUrl = "https://api.waifu.pics/sfw/pat";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("‚ùå Error in .pat command:", error);
            reply(`‚ùå *Error in .pat command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "smug",
        desc: "Send a smug reaction GIF.",
        category: "fun",
        react: "üòè",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} is smug at @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is feeling smug!`
                : `> ¬© ùêèùêéùêñùêÑùêëùêÑùêÉ ùêÅùêò ùêíùêîùêÅùêôùêÑùêëùêé `;

            const apiUrl = "https://api.waifu.pics/sfw/smug";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("‚ùå Error in .smug command:", error);
            reply(`‚ùå *Error in .smug command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "bonk",
        desc: "Send a bonk reaction GIF.",
        category: "fun",
        react: "üî®",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} bonked @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is bonking everyone!`
                : `> ¬© ùêèùêéùêñùêÑùêëùêÑùêÉ ùêÅùêò ùêíùêîùêÅùêôùêÑùêëùêé`;

            const apiUrl = "https://api.waifu.pics/sfw/bonk";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("‚ùå Error in .bonk command:", error);
            reply(`‚ùå *Error in .bonk command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);


cmd(
    {
        pattern: "yeet",
        desc: "Send a yeet reaction GIF.",
        category: "fun",
        react: "üí®",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} yeeted @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is yeeting everyone!`
                : `> ¬© ùêèùêéùêñùêÑùêëùêÑùêÉ ùêÅùêò ùêíùêîùêÅùêôùêÑùêëùêé üñ§`;

            const apiUrl = "https://api.waifu.pics/sfw/yeet";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("‚ùå Error in .yeet command:", error);
            reply(`‚ùå *Error in .yeet command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "blush",
        desc: "Send a blush reaction GIF.",
        category: "fun",
        react: "üòä",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} is blushing at @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is blushing!`
                : `> ¬© ùêèùêéùêñùêÑùêëùêÑùêÉ ùêÅùêò ùêíùêîùêÅùêôùêÑùêëùêé`;

            const apiUrl = "https://api.waifu.pics/sfw/blush";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("‚ùå Error in .blush command:", error);
            reply(`‚ùå *Error in .blush command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);  
  
cmd(
    {
        pattern: "handhold",
        desc: "Send a hand-holding reaction GIF.",
        category: "fun",
        react: "ü§ù",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} is holding hands with @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} wants to hold hands with everyone!`
                : `> ¬© ùêèùêéùêñùêÑùêëùêÑùêÉ ùêÅùêò ùêíùêîùêÅùêôùêÑùêëùêé `;

            const apiUrl = "https://api.waifu.pics/sfw/handhold";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("‚ùå Error in .handhold command:", error);
            reply(`‚ùå *Error in .handhold command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);


cmd(
    {
        pattern: "highfive",
        desc: "Send a high-five reaction GIF.",
        category: "fun",
        react: "‚úã",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} gave a high-five to @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is high-fiving everyone!`
                : `> ¬© ùêèùêéùêñùêÑùêëùêÑùêÉ ùêÅùêò ùêíùêîùêÅùêôùêÑùêëùêé`;

            const apiUrl = "https://api.waifu.pics/sfw/highfive";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("‚ùå Error in .highfive command:", error);
            reply(`‚ùå *Error in .highfive command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);  

cmd(
    {
        pattern: "nom",
        desc: "Send a nom reaction GIF.",
        category: "fun",
        react: "üçΩÔ∏è",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} is nomming @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is nomming everyone!`
                : `> ¬© ùêèùêéùêñùêÑùêëùêÑùêÉ ùêÅùêò ùêíùêîùêÅùêôùêÑùêëùêé`;

            const apiUrl = "https://api.waifu.pics/sfw/nom";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("‚ùå Error in .nom command:", error);
            reply(`‚ùå *Error in .nom command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "wave",
        desc: "Send a wave reaction GIF.",
        category: "fun",
        react: "üëã",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} waved at @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is waving at everyone!`
                : `> ¬© ùêèùêéùêñùêÑùêëùêÑùêÉ ùêÅùêò ùêíùêîùêÅùêôùêÑùêëùêé`;

            const apiUrl = "https://api.waifu.pics/sfw/wave";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("‚ùå Error in .wave command:", error);
            reply(`‚ùå *Error in .wave command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "smile",
        desc: "Send a smile reaction GIF.",
        category: "fun",
        react: "üòÅ",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} smiled at @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is smiling at everyone!`
                : `> ¬© ùêèùêéùêñùêÑùêëùêÑùêÉ ùêÅùêò ùêíùêîùêÅùêôùêÑùêëùêé`;

            const apiUrl = "https://api.waifu.pics/sfw/smile";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("‚ùå Error in .smile command:", error);
            reply(`‚ùå *Error in .smile command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "wink",
        desc: "Send a wink reaction GIF.",
        category: "fun",
        react: "üòâ",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} winked at @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is winking at everyone!`
                : `> ¬© ùêèùêéùêñùêÑùêëùêÑùêÉ ùêÅùêò ùêíùêîùêÅùêôùêÑùêëùêé`;

            const apiUrl = "https://api.waifu.pics/sfw/wink";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("‚ùå Error in .wink command:", error);
            reply(`‚ùå *Error in .wink command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "happy",
        desc: "Send a happy reaction GIF.",
        category: "fun",
        react: "üòä",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} is happy with @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is happy with everyone!`
                : `> ¬© ùêèùêéùêñùêÑùêëùêÑùêÉ ùêÅùêò ùêíùêîùêÅùêôùêÑùêëùêé `;

            const apiUrl = "https://api.waifu.pics/sfw/happy";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("‚ùå Error in .happy command:", error);
            reply(`‚ùå *Error in .happy command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "glomp",
        desc: "Send a glomp reaction GIF.",
        category: "fun",
        react: "ü§ó",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} glomped @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is glomping everyone!`
                : `> ¬© ùêèùêéùêñùêÑùêëùêÑùêÉ ùêÅùêò ùêíùêîùêÅùêôùêÑùêëùêé `;

            const apiUrl = "https://api.waifu.pics/sfw/glomp";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("‚ùå Error in .glomp command:", error);
            reply(`‚ùå *Error in .glomp command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "bite",
        desc: "Send a bite reaction GIF.",
        category: "fun",
        react: "ü¶∑",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} bit @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is biting everyone!`
                : `> ¬© ùêèùêéùêñùêÑùêëùêÑùêÉ ùêÅùêò ùêíùêîùêÅùêôùêÑùêëùêé `;

            const apiUrl = "https://api.waifu.pics/sfw/bite";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("‚ùå Error in .bite command:", error);
            reply(`‚ùå *Error in .bite command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "poke",
        desc: "Send a poke reaction GIF.",
        category: "fun",
        react: "üëâ",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} poked @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} poked everyone`
                : `> ¬© ùêèùêéùêñùêÑùêëùêÑùêÉ ùêÅùêò ùêíùêîùêÅùêôùêÑùêëùêé `;

            const apiUrl = "https://api.waifu.pics/sfw/poke";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("‚ùå Error in .poke command:", error);
            reply(`‚ùå *Error in .poke command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);
  
  
cmd(
    {
        pattern: "cringe",
        desc: "Send a cringe reaction GIF.",
        category: "fun",
        react: "üò¨",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} thinks @${mentionedUser.split("@")[0]} is cringe`
                : isGroup
                ? `${sender} finds everyone cringe`
                : `> ¬© ùêèùêéùêñùêÑùêëùêÑùêÉ ùêÅùêò ùêíùêîùêÅùêôùêÑùêëùêé`;

            const apiUrl = "https://api.waifu.pics/sfw/cringe";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("‚ùå Error in .cringe command:", error);
            reply(`‚ùå *Error in .cringe command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);


cmd(
    {
        pattern: "dance",
        desc: "Send a dance reaction GIF.",
        category: "fun",
        react: "üíÉ",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message = mentionedUser
                ? `${sender} danced with @${mentionedUser.split("@")[0]}`
                : isGroup
                ? `${sender} is dancing with everyone`
                : `> ¬© ùêèùêéùêñùêÑùêëùêÑùêÉ ùêÅùêò ùêíùêîùêÅùêôùêÑùêëùêé`;

            const apiUrl = "https://api.waifu.pics/sfw/dance";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("‚ùå Error in .dance command:", error);
            reply(`‚ùå *Error in .dance command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);


  
cmd(
    {
        pattern: "kill",
        desc: "Send a kill reaction GIF.",
        category: "fun",
        react: "üî™",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message;
            if (mentionedUser) {
                let target = `@${mentionedUser.split("@")[0]}`;
                message = `${sender} killed ${target}`;
            } else if (isGroup) {
                message = `${sender} killed everyone`;
            } else {
                message = `> ¬© ùêèùêéùêñùêÑùêëùêÑùêÉ ùêÅùêò ùêíùêîùêÅùêôùêÑùêëùêé`;
            }

            const apiUrl = "https://api.waifu.pics/sfw/kill";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("‚ùå Error in .kill command:", error);
            reply(`‚ùå *Error in .kill command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "slap",
        desc: "Send a slap reaction GIF.",
        category: "fun",
        react: "‚úä",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message;
            if (mentionedUser) {
                let target = `@${mentionedUser.split("@")[0]}`;
                message = `${sender} slapped ${target}`;
            } else if (isGroup) {
                message = `${sender} slapped everyone`;
            } else {
                message = `> ¬© ùêèùêéùêñùêÑùêëùêÑùêÉ ùêÅùêò ùêíùêîùêÅùêôùêÑùêëùêé`;
            }

            const apiUrl = "https://api.waifu.pics/sfw/slap";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("‚ùå Error in .slap command:", error);
            reply(`‚ùå *Error in .slap command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);

cmd(
    {
        pattern: "kiss",
        desc: "Send a kiss reaction GIF.",
        category: "fun",
        react: "üíã",
        filename: __filename,
        use: "@tag (optional)",
    },
    async (conn, mek, m, { args, q, reply }) => {
        try {
            let sender = `@${mek.sender.split("@")[0]}`;
            let mentionedUser = m.mentionedJid[0] || (mek.quoted && mek.quoted.sender);
            let isGroup = m.isGroup;

            let message;
            if (mentionedUser) {
                let target = `@${mentionedUser.split("@")[0]}`;
                message = `${sender} kissed ${target}`;
            } else if (isGroup) {
                message = `${sender} kissed everyone`;
            } else {
                message = `> ¬© ùêèùêéùêñùêÑùêëùêÑùêÉ ùêÅùêò ùêíùêîùêÅùêôùêÑùêëùêé`;
            }

            const apiUrl = "https://api.waifu.pics/sfw/kiss";
            let res = await axios.get(apiUrl);
            let gifUrl = res.data.url;

            let gifBuffer = await fetchGif(gifUrl);
            let videoBuffer = await gifToVideo(gifBuffer);

            await conn.sendMessage(
                mek.chat,
                { video: videoBuffer, caption: message, gifPlayback: true, mentions: [mek.sender, mentionedUser].filter(Boolean) },
                { quoted: mek }
            );
        } catch (error) {
            console.error("‚ùå Error in .kiss command:", error);
            reply(`‚ùå *Error in .kiss command:*\n\`\`\`${error.message}\`\`\``);
        }
    }
);
